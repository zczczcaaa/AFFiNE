/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Application {
  constructor(processId: number)
  get processId(): number
  get processGroupId(): number
  get bundleIdentifier(): string
  get name(): string
  get icon(): Buffer
}

export declare class ApplicationListChangedSubscriber {
  unsubscribe(): void
}

export declare class ApplicationStateChangedSubscriber {
  unsubscribe(): void
}

export declare class AudioTapStream {
  stop(): void
  get sampleRate(): number
  get channels(): number
}

export declare class DocStorage {
  constructor(path: string)
  validate(): Promise<boolean>
  setSpaceId(spaceId: string): Promise<void>
}

export declare class DocStoragePool {
  constructor()
  /** Initialize the database and run migrations. */
  connect(universalId: string, path: string): Promise<void>
  disconnect(universalId: string): Promise<void>
  checkpoint(universalId: string): Promise<void>
  setSpaceId(universalId: string, spaceId: string): Promise<void>
  pushUpdate(universalId: string, docId: string, update: Uint8Array): Promise<Date>
  getDocSnapshot(universalId: string, docId: string): Promise<DocRecord | null>
  setDocSnapshot(universalId: string, snapshot: DocRecord): Promise<boolean>
  getDocUpdates(universalId: string, docId: string): Promise<Array<DocUpdate>>
  markUpdatesMerged(universalId: string, docId: string, updates: Array<Date>): Promise<number>
  deleteDoc(universalId: string, docId: string): Promise<void>
  getDocClocks(universalId: string, after?: Date | undefined | null): Promise<Array<DocClock>>
  getDocClock(universalId: string, docId: string): Promise<DocClock | null>
  getBlob(universalId: string, key: string): Promise<Blob | null>
  setBlob(universalId: string, blob: SetBlob): Promise<void>
  deleteBlob(universalId: string, key: string, permanently: boolean): Promise<void>
  releaseBlobs(universalId: string): Promise<void>
  listBlobs(universalId: string): Promise<Array<ListedBlob>>
  getPeerRemoteClocks(universalId: string, peer: string): Promise<Array<DocClock>>
  getPeerRemoteClock(universalId: string, peer: string, docId: string): Promise<DocClock | null>
  setPeerRemoteClock(universalId: string, peer: string, docId: string, clock: Date): Promise<void>
  getPeerPulledRemoteClocks(universalId: string, peer: string): Promise<Array<DocClock>>
  getPeerPulledRemoteClock(universalId: string, peer: string, docId: string): Promise<DocClock | null>
  setPeerPulledRemoteClock(universalId: string, peer: string, docId: string, clock: Date): Promise<void>
  getPeerPushedClocks(universalId: string, peer: string): Promise<Array<DocClock>>
  getPeerPushedClock(universalId: string, peer: string, docId: string): Promise<DocClock | null>
  setPeerPushedClock(universalId: string, peer: string, docId: string, clock: Date): Promise<void>
  clearClocks(universalId: string): Promise<void>
}

export declare class Mp3Encoder {
  constructor(options: EncodeOptions)
  encode(input: Float32Array): Uint8Array
}

export declare class RecordingPermissions {
  audio: boolean
  screen: boolean
}

export declare class ShareableContent {
  static onApplicationListChanged(callback: ((err: Error | null, ) => void)): ApplicationListChangedSubscriber
  static onAppStateChanged(app: TappableApplication, callback: ((err: Error | null, ) => void)): ApplicationStateChangedSubscriber
  constructor()
  applications(): Array<TappableApplication>
  applicationWithProcessId(processId: number): Application | null
  tappableApplicationWithProcessId(processId: number): TappableApplication | null
  checkRecordingPermissions(): RecordingPermissions
  static tapGlobalAudio(excludedProcesses: Array<TappableApplication> | undefined | null, audioStreamCallback: ((err: Error | null, arg: Float32Array) => void)): AudioTapStream
}

export declare class SqliteConnection {
  constructor(path: string)
  connect(): Promise<void>
  addBlob(key: string, blob: Uint8Array): Promise<void>
  getBlob(key: string): Promise<BlobRow | null>
  deleteBlob(key: string): Promise<void>
  getBlobKeys(): Promise<Array<string>>
  getUpdates(docId?: string | undefined | null): Promise<Array<UpdateRow>>
  getDocTimestamps(): Promise<Array<DocTimestampRow>>
  deleteUpdates(docId?: string | undefined | null): Promise<void>
  getUpdatesCount(docId?: string | undefined | null): Promise<number>
  getAllUpdates(): Promise<Array<UpdateRow>>
  insertUpdates(updates: Array<InsertRow>): Promise<void>
  replaceUpdates(docId: string | undefined | null, updates: Array<InsertRow>): Promise<void>
  getServerClock(key: string): Promise<BlobRow | null>
  setServerClock(key: string, data: Uint8Array): Promise<void>
  getServerClockKeys(): Promise<Array<string>>
  clearServerClock(): Promise<void>
  delServerClock(key: string): Promise<void>
  getSyncMetadata(key: string): Promise<BlobRow | null>
  setSyncMetadata(key: string, data: Uint8Array): Promise<void>
  getSyncMetadataKeys(): Promise<Array<string>>
  clearSyncMetadata(): Promise<void>
  delSyncMetadata(key: string): Promise<void>
  initVersion(): Promise<void>
  setVersion(version: number): Promise<void>
  getMaxVersion(): Promise<number>
  close(): Promise<void>
  get isClose(): boolean
  static validate(path: string): Promise<ValidationResult>
  migrateAddDocId(): Promise<void>
  /**
   * Flush the WAL file to the database file.
   * See https://www.sqlite.org/pragma.html#pragma_wal_checkpoint:~:text=PRAGMA%20schema.wal_checkpoint%3B
   */
  checkpoint(): Promise<void>
}

export declare class TappableApplication {
  constructor(objectId: AudioObjectID)
  static fromApplication(app: Application, objectId: AudioObjectID): TappableApplication
  get processId(): number
  get processGroupId(): number
  get bundleIdentifier(): string
  get name(): string
  get objectId(): number
  get icon(): Buffer
  get isRunning(): boolean
  tapAudio(audioStreamCallback: ((err: Error | null, arg: Float32Array) => void)): AudioTapStream
}

/**Enumeration of valid values for `set_brate` */
export declare enum Bitrate {
  /**8_000 */
  Kbps8 = 8,
  /**16_000 */
  Kbps16 = 16,
  /**24_000 */
  Kbps24 = 24,
  /**32_000 */
  Kbps32 = 32,
  /**40_000 */
  Kbps40 = 40,
  /**48_000 */
  Kbps48 = 48,
  /**64_000 */
  Kbps64 = 64,
  /**80_000 */
  Kbps80 = 80,
  /**96_000 */
  Kbps96 = 96,
  /**112_000 */
  Kbps112 = 112,
  /**128_000 */
  Kbps128 = 128,
  /**160_000 */
  Kbps160 = 160,
  /**192_000 */
  Kbps192 = 192,
  /**224_000 */
  Kbps224 = 224,
  /**256_000 */
  Kbps256 = 256,
  /**320_000 */
  Kbps320 = 320
}

export interface Blob {
  key: string
  data: Uint8Array
  mime: string
  size: number
  createdAt: Date
}

export interface BlobRow {
  key: string
  data: Buffer
  timestamp: Date
}

export declare function decodeAudio(buf: Uint8Array, destSampleRate?: number | undefined | null, filename?: string | undefined | null, signal?: AbortSignal | undefined | null): Promise<Float32Array>

/** Decode audio file into a Float32Array */
export declare function decodeAudioSync(buf: Uint8Array, destSampleRate?: number | undefined | null, filename?: string | undefined | null): Float32Array

export interface DocClock {
  docId: string
  timestamp: Date
}

export interface DocRecord {
  docId: string
  bin: Uint8Array
  timestamp: Date
}

export interface DocTimestampRow {
  docId?: string
  timestamp: Date
}

export interface DocUpdate {
  docId: string
  timestamp: Date
  bin: Uint8Array
}

export interface EncodeOptions {
  channels: number
  quality?: Quality
  bitrate?: Bitrate
  sampleRate?: number
  mode?: Mode
}

export interface InsertRow {
  docId?: string
  data: Uint8Array
}

export interface ListedBlob {
  key: string
  size: number
  mime: string
  createdAt: Date
}

export declare function mintChallengeResponse(resource: string, bits?: number | undefined | null): Promise<string>

/** MPEG mode */
export declare enum Mode {
  Mono = 0,
  Stereo = 1,
  JointStereo = 2,
  DualChannel = 3,
  NotSet = 4
}

/**
 *Possible quality parameter.
 *From best(0) to worst(9)
 */
export declare enum Quality {
  /**Best possible quality */
  Best = 0,
  /**Second best */
  SecondBest = 1,
  /**Close to best */
  NearBest = 2,
  /**Very nice */
  VeryNice = 3,
  /**Nice */
  Nice = 4,
  /**Good */
  Good = 5,
  /**Decent */
  Decent = 6,
  /**Okayish */
  Ok = 7,
  /**Almost worst */
  SecondWorst = 8,
  /**Worst */
  Worst = 9
}

export interface SetBlob {
  key: string
  data: Uint8Array
  mime: string
}

export interface UpdateRow {
  id: number
  timestamp: Date
  data: Buffer
  docId?: string
}

export declare enum ValidationResult {
  MissingTables = 0,
  MissingDocIdColumn = 1,
  MissingVersionColumn = 2,
  GeneralError = 3,
  Valid = 4
}

export declare function verifyChallengeResponse(response: string, bits: number, resource: string): Promise<boolean>
